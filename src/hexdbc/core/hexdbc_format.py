import struct
from pathlib import Path
from typing import List, Optional, Dict, Any

from hexdbc.core.parser import DBCFile, DBCHeader
from hexdbc.core.schema import SchemaManager, SchemaDef, FieldType, FieldDef


class HexDBCGenerator:
    def __init__(self, schema_manager: Optional[SchemaManager] = None):
        # Use provided schema manager or create a new one
        self.schema_manager = schema_manager or SchemaManager()
    
    def generate(self, dbc: DBCFile, dbc_name: str = "Unknown") -> str:
        lines = []

        # Header info
        lines.append(f"# {dbc_name}.dbc - Generated by HexDBC")
        lines.append(f"# Records: {dbc.header.record_count}")
        lines.append(f"# Fields: {dbc.header.field_count}")
        lines.append("")

        # Fetch schema; fallback if missing
        schema = self.schema_manager.get_schema(dbc_name)
        if not schema:
            schema = self.schema_manager.generate_fallback_schema(dbc.header.field_count, dbc_name)
            lines.append(f"# Note: No built-in schema for {dbc_name}, using auto-generated fallback")
            lines.append("")

        lines.append(f'@schema "{schema.name}"')
        lines.append("")

        # Record function name (lowercase, strip 'table' suffix)
        record_name = self._get_record_name(dbc_name)

        # Generate each record
        for record_idx, record in enumerate(dbc.records):
            record_id = record[0] if record else record_idx
            lines.append(f"{record_name}({record_id}) {{")

            for field_idx, value in enumerate(record):
                if field_idx == 0:
                    continue  # ID is in the record call

                field_def = schema.get_field(field_idx) if field_idx < len(schema.fields) else None
                field_name = field_def.name if field_def else f"field_{field_idx}"
                field_type = field_def.type if field_def else FieldType.UINT

                formatted_value = self._format_value(value, field_type, field_def, schema, dbc)

                # Add description comment for unknown fields
                comment = f"  # {field_def.description}" if field_def and field_def.description and field_def.name.startswith("Unknown") else ""

                lines.append(f"    {field_name} = {formatted_value}{comment}")

            lines.append("}\n")

        return "\n".join(lines)

    def _get_record_name(self, dbc_name: str) -> str:
        name = dbc_name.lower()
        if name.endswith("table"):
            name = name[:-5]  # drop common suffix
        return name

    def _format_value(
        self,
        value: int,
        field_type: FieldType,
        field_def: Optional[FieldDef],
        schema: SchemaDef,
        dbc: DBCFile
    ) -> str:
        """Format a single field value according to type and schema."""
        if field_type in (FieldType.STRING, FieldType.LOCSTRING):
            # Fetch string from DBC string block
            string_value = dbc.get_string(value)
            # Escape special characters
            string_value = string_value.replace('\\', '\\\\').replace('"', '\\"').replace('\n', '\\n').replace('\r', '\\r')
            return f'"{string_value}"'

        elif field_type == FieldType.FLOAT:
            # Convert raw int bits to float
            fval = struct.unpack('<f', struct.pack('<I', value))[0]
            return f"{fval:.6g}"

        elif field_type == FieldType.INT:
            # Handle signed int wraparound
            return str(value - 0x100000000) if value >= 0x80000000 else str(value)

        elif field_type == FieldType.ENUM and field_def and field_def.enum_name:
            # Try to map numeric value to enum name
            enum_map = schema.enums.get(field_def.enum_name, {})
            return enum_map.get(value, str(value))

        elif field_type == FieldType.FLAGS:
            return "0" if value == 0 else f"0x{value:08X}"

        else:
            return str(value)  # fallback: unsigned int


class HexDBCParser:

    def __init__(self, schema_manager: Optional[SchemaManager] = None):
        self.schema_manager = schema_manager or SchemaManager()
        self._current_schema: Optional[SchemaDef] = None
        self._errors: List[str] = []

    @property
    def errors(self) -> List[str]:
        return self._errors.copy()

    def parse(self, code: str, original_dbc: Optional[DBCFile] = None) -> DBCFile:
        self._errors.clear()
        lines = code.split("\n")
        records: List[Dict[str, Any]] = []
        current_record: Optional[Dict[str, Any]] = None
        current_id: Optional[int] = None
        schema_name = "Unknown"
        field_count = 0

        for line_num, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith("#"):
                continue  # ignore blank lines & comments

            # Handle schema directive
            if line.startswith("@schema"):
                match = self._parse_schema_directive(line)
                if match:
                    schema_name, self._current_schema = match
                continue

            # Handle record start
            if "(" in line and line.rstrip().endswith("{"):
                current_id = self._parse_record_start(line, line_num)
                current_record = {"_id": current_id}
                continue

            # Handle record end
            if line == "}":
                if current_record:
                    records.append(current_record)
                    field_count = max(field_count, len(current_record))
                current_record = None
                current_id = None
                continue

            # Parse field assignment
            if "=" in line and current_record:
                field_name, field_value = self._parse_field_assignment(line, line_num)
                if field_name:
                    current_record[field_name] = field_value

        # Convert parsed dicts into DBCFile
        return self._build_dbc_file(records, original_dbc, schema_name, field_count)

    def _parse_schema_directive(self, line: str) -> Optional[tuple]:
        import re
        match = re.search(r'@schema\s+"([^"]+)"', line)
        if match:
            name = match.group(1)
            schema = self.schema_manager.get_schema(name)
            return name, schema
        return None

    def _parse_record_start(self, line: str, line_num: int) -> int:
        import re
        match = re.search(r'\w+\((\d+)\)\s*\{', line)
        if match:
            return int(match.group(1))
        self._errors.append(f"Line {line_num}: Could not parse record ID")
        return 0

    def _parse_field_assignment(self, line: str, line_num: int) -> tuple:
        if "#" in line:
            line = line[:line.index("#")]  # remove inline comments
        parts = line.split("=", 1)
        if len(parts) != 2:
            self._errors.append(f"Line {line_num}: Invalid assignment")
            return None, None
        field_name, value_str = parts[0].strip(), parts[1].strip()
        value = self._parse_value(value_str, field_name, line_num)
        return field_name, value

    def _parse_value(self, value_str: str, field_name: str, line_num: int) -> Any:
        # String literal
        if value_str.startswith('"') and value_str.endswith('"'):
            s = value_str[1:-1].replace('\\n', '\n').replace('\\r', '\r').replace('\\"', '"').replace('\\\\', '\\')
            return ("string", s)

        # Hex (flags)
        if value_str.lower().startswith("0x"):
            try:
                return ("uint", int(value_str, 16))
            except ValueError:
                self._errors.append(f"Line {line_num}: Invalid hex value {value_str}")
                return ("uint", 0)

        # Float
        if "." in value_str or "e" in value_str.lower():
            try:
                return ("float", float(value_str))
            except ValueError:
                self._errors.append(f"Line {line_num}: Invalid float value {value_str}")
                return ("float", 0.0)

        # Enum (uppercase identifiers)
        if value_str.isupper() or (value_str[0].isupper() and "_" in value_str):
            if self._current_schema:
                for enum_name, enum_map in self._current_schema.enums.items():
                    for val, name in enum_map.items():
                        if name == value_str:
                            return ("uint", val)
            self._errors.append(f"Line {line_num}: Unknown enum value {value_str}")
            return ("uint", 0)

        # Integer
        try:
            int_val = int(value_str)
            return ("int", int_val) if int_val < 0 else ("uint", int_val)
        except ValueError:
            self._errors.append(f"Line {line_num}: Invalid value {value_str}")
            return ("uint", 0)

    def _build_dbc_file(
        self,
        records: List[Dict[str, Any]],
        original_dbc: Optional[DBCFile],
        schema_name: str,
        field_count: int
    ) -> DBCFile:
        from hexdbc.core.parser import DBCFile, DBCHeader

        # Start string block with null byte
        string_block = bytearray(b"\x00")
        string_offsets: Dict[str, int] = {"": 0}

        def get_string_offset(s: str) -> int:
            if s in string_offsets:
                return string_offsets[s]
            offset = len(string_block)
            string_block.extend(s.encode("utf-8") + b"\x00")
            string_offsets[s] = offset
            return offset

        # Determine field count
        if original_dbc:
            actual_field_count = original_dbc.header.field_count
        else:
            actual_field_count = max(
                max((self._get_field_index(k) for k in r.keys() if k != "_id"), default=0) + 1
                for r in records
            ) if records else 1

        # Map field names to indices (schema first, then fallback)
        field_name_to_index: Dict[str, int] = {}
        if self._current_schema:
            for i, field_def in enumerate(self._current_schema.fields):
                field_name_to_index[field_def.name] = i
        for i in range(actual_field_count):
            field_name_to_index[f"field_{i}"] = i

        # Map original DBC records if available
        original_records_by_id: Dict[int, List[int]] = {}
        if original_dbc:
            for record in original_dbc.records:
                if record:
                    original_records_by_id[record[0]] = record

        dbc_records = []

        for record_data in records:
            record_id = record_data.get("_id", 0)
            fields = list(original_records_by_id.get(record_id, [0] * actual_field_count))
            fields[0] = record_id

            while len(fields) < actual_field_count:
                fields.append(0)

            # Fill parsed values
            for field_name, parsed_value in record_data.items():
                if field_name == "_id":
                    continue
                field_idx = field_name_to_index.get(field_name) or self._get_field_index(field_name)
                if field_idx is None or not (0 <= field_idx < actual_field_count):
                    continue

                value_type, value = parsed_value
                if value_type == "string":
                    fields[field_idx] = get_string_offset(value)
                elif value_type == "float":
                    fields[field_idx] = struct.unpack("<I", struct.pack("<f", value))[0]
                elif value_type == "int" and value < 0:
                    fields[field_idx] = (value + 0x100000000) & 0xFFFFFFFF
                else:
                    fields[field_idx] = value & 0xFFFFFFFF

            dbc_records.append(fields[:actual_field_count])

        record_size = actual_field_count * 4
        header = DBCHeader(
            magic=b"WDBC",
            record_count=len(dbc_records),
            field_count=actual_field_count,
            record_size=record_size,
            string_block_size=len(string_block),
        )

        return DBCFile(header=header, records=dbc_records, string_block=bytes(string_block))

    def _get_field_index(self, field_name: str) -> Optional[int]:
        import re
        match = re.match(r"field_(\d+)", field_name)
        return int(match.group(1)) if match else None
